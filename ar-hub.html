<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quest 3 AR Hub</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div id="info">
        Put on your Quest 3 and click "Enter AR" to see the hub fixed in space
    </div>
    
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.158.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { VRButton } from 'three/addons/webxr/VRButton.js';
        import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';

        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        document.body.appendChild(renderer.domElement);

        // Add AR button
        const arButton = VRButton.createButton(renderer, {
            requiredFeatures: ['local-floor'],
            optionalFeatures: ['hand-tracking', 'layers', 'anchors']
        });
        document.body.appendChild(arButton);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(0, 5, 5);
        scene.add(directionalLight);

        // Create AR Hub Group (fixed in space)
        const hubGroup = new THREE.Group();
        hubGroup.position.set(0, 1.5, -2); // 2 meters in front, 1.5m high
        scene.add(hubGroup);

        // Main Panel
        const panelGeometry = new THREE.PlaneGeometry(1.5, 1);
        const panelMaterial = new THREE.MeshStandardMaterial({
            color: 0x222222,
            transparent: true,
            opacity: 0.95,
            side: THREE.DoubleSide
        });
        const mainPanel = new THREE.Mesh(panelGeometry, panelMaterial);
        hubGroup.add(mainPanel);

        // Panel border
        const borderGeometry = new THREE.EdgesGeometry(panelGeometry);
        const borderMaterial = new THREE.LineBasicMaterial({ color: 0x00ffff, linewidth: 2 });
        const border = new THREE.LineSegments(borderGeometry, borderMaterial);
        mainPanel.add(border);

        // Title text (using simple geometry)
        function createTextPanel(text, color, width = 0.8, height = 0.15) {
            const textGeo = new THREE.PlaneGeometry(width, height);
            const textMat = new THREE.MeshStandardMaterial({
                color: color,
                transparent: true,
                opacity: 0.9
            });
            const textMesh = new THREE.Mesh(textGeo, textMat);
            
            // Add border to text panel
            const textBorder = new THREE.EdgesGeometry(textGeo);
            const textBorderMat = new THREE.LineBasicMaterial({ color: 0xffffff });
            const textBorderMesh = new THREE.LineSegments(textBorder, textBorderMat);
            textMesh.add(textBorderMesh);
            
            return textMesh;
        }

        // Title
        const title = createTextPanel('AR HUB', 0x0066ff, 1.2, 0.2);
        title.position.set(0, 0.4, 0.01);
        hubGroup.add(title);

        // Menu buttons
        const buttonPositions = [
            { y: 0.1, label: 'Apps', color: 0x00aa00 },
            { y: -0.15, label: 'Settings', color: 0xaa6600 },
            { y: -0.4, label: 'Exit', color: 0xaa0000 }
        ];

        const buttons = [];
        buttonPositions.forEach((btn, index) => {
            const button = createTextPanel(btn.label, btn.color, 1.0, 0.18);
            button.position.set(0, btn.y, 0.01);
            button.userData = { originalColor: btn.color, label: btn.label };
            buttons.push(button);
            hubGroup.add(button);
        });

        // Add floating particles around the hub
        const particlesGeometry = new THREE.BufferGeometry();
        const particlesCount = 50;
        const positions = new Float32Array(particlesCount * 3);

        for (let i = 0; i < particlesCount * 3; i++) {
            positions[i] = (Math.random() - 0.5) * 3;
        }

        particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        const particlesMaterial = new THREE.PointsMaterial({
            color: 0x00ffff,
            size: 0.02,
            transparent: true,
            opacity: 0.6
        });
        const particles = new THREE.Points(particlesGeometry, particlesMaterial);
        hubGroup.add(particles);

        // Controllers setup
        const controllerModelFactory = new XRControllerModelFactory();
        const controllers = [];

        for (let i = 0; i < 2; i++) {
            const controller = renderer.xr.getController(i);
            controller.addEventListener('selectstart', onSelectStart);
            controller.addEventListener('selectend', onSelectEnd);
            scene.add(controller);

            const grip = renderer.xr.getControllerGrip(i);
            grip.add(controllerModelFactory.createControllerModel(grip));
            scene.add(grip);

            // Add ray to controller
            const geometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(0, 0, -1)
            ]);
            const line = new THREE.Line(geometry, new THREE.LineBasicMaterial({ color: 0x00ffff }));
            line.scale.z = 5;
            controller.add(line);

            controllers.push({ controller, grip });
        }

        // Raycaster for interaction
        const raycaster = new THREE.Raycaster();
        let selectedButton = null;

        function onSelectStart(event) {
            const controller = event.target;
            const tempMatrix = new THREE.Matrix4();
            tempMatrix.identity().extractRotation(controller.matrixWorld);

            raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
            raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);

            const intersects = raycaster.intersectObjects(buttons, false);

            if (intersects.length > 0) {
                selectedButton = intersects[0].object;
                selectedButton.material.color.setHex(0xffffff);
                selectedButton.scale.set(1.1, 1.1, 1.1);
                
                console.log(`Selected: ${selectedButton.userData.label}`);
            }
        }

        function onSelectEnd() {
            if (selectedButton) {
                selectedButton.material.color.setHex(selectedButton.userData.originalColor);
                selectedButton.scale.set(1, 1, 1);
                selectedButton = null;
            }
        }

        // Animation loop
        let time = 0;
        renderer.setAnimationLoop(() => {
            time += 0.01;

            // Animate particles
            const positions = particles.geometry.attributes.position.array;
            for (let i = 0; i < positions.length; i += 3) {
                positions[i + 1] += Math.sin(time + i) * 0.001;
            }
            particles.geometry.attributes.position.needsUpdate = true;
            particles.rotation.y += 0.001;

            // Subtle panel glow animation
            border.material.opacity = 0.5 + Math.sin(time * 2) * 0.3;

            renderer.render(scene, camera);
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Session start/end handlers
        renderer.xr.addEventListener('sessionstart', () => {
            document.getElementById('info').style.display = 'none';
            console.log('AR Session Started');
        });

        renderer.xr.addEventListener('sessionend', () => {
            document.getElementById('info').style.display = 'block';
            console.log('AR Session Ended');
        });

    </script>
</body>
</html>
